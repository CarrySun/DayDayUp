> 原文地址 http://blog.csdn.net/eirlys_north/article/details/52959540

# 一、定义

## 1、时间频度

一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n)。

## 2、时间复杂度

为了知道时间频度 T(n)变化时呈现的规律，引入了时间复杂度概念。

一般情况下，算法中基本操作重复执行的次数是问题规模 n 的某个函数，用 T(n) 表示，若有某个辅助函数 f(n), 使得当 n 趋近于无穷大时，T（n)/f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数。记作 T(n)=Ｏ(f(n))。称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

> 常见的时间复杂度有：
>
> > 常数阶 O(1) < 对数阶 O(log2n) < 线性阶 O(n) < 线性对数阶 O(nlog2n) < 平方阶 O(n^2) < 方阶 O(n^3) < k 次方阶 O(n^k) < 指数阶 O(2^n) < O(n!) < O(n^n)

## 3、最坏时间复杂度和平均时间复杂度

> 最坏情况下的时间复杂度称最坏时间复杂度 T(n)=0(n)。

算法在任何输入实例上运行时间的上界 通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间

> 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。

平均情况通常指的是一种数学期望值，通过运行一定数量的实验数据后估算出来的

平均时间复杂度缺点：难计算、有很多算法的平均情况和最差情况的复杂度是一样的、而且输入数据的分布函数很可能是你没法知道

# 二、求时间复杂度

## 1、根据定义，可以归纳出基本的计算步骤

* （1）计算出基本操作的执行次数 T(n)
    基本操作即算法中的每条语句的执行次数一般默认为考虑最坏的情况。
* （2）计算出 T(n) 的数量级
      求 T(n) 的数量级，只要将 T(n) 进行如下一些操作：
      忽略常量、低次幂和最高次幂的系数
      令 f(n)=T(n) 的数量级。
* （3）用大 O 来表示时间复杂度

```js
// /时间复杂度：T（n）=O（n^3)
for (i = 1; i <= n; ++i) {
  for (j = 1; j <= n; ++j) {
    c[i][j] = 0; // 该步骤属于基本操作 执行次数：n^2
    for (k = 1; k <= n; ++k) {
      c[i][j] += a[i][k] * b[k][j]; // 该步骤属于基本操作 执行次数：n^3
    }
  }
}
```

## 2、于是我们发现根本没必要都算，所以我们有了精简后的步骤：

* 找到执行次数最多的语句
* 计算语句执行次数的数量级
* 用大 O 来表示结果

eg:

```js
//循环了n*n次，当然是O(n^2)
for(i = 1; i <= n; i++)
  for(j = 1; j<=n; j++)
    s++;

//循环了n-1≈n次，所以是O(n)
i = 1;
k = 0;
while (i <= n-1) {
  k += 10*i;
  i ++;
}

//循环了(1^2+2^2+3^2+...+n^2)=n(n+1)(2n+1)/6≈(n^3)/3，即O（n^3)
for(i = 1; i< = n; i++)
  for(j = 1; j< = i; j++)
    for(k = 1; k< = j; k++)
      x = x+1;

//T(n)=O(1)，与n无关
x=91;
y=100;
while (y > 0)
  if (x > 100) {
    x = x - 10;
    y --;
  }
  else
    x++;
// 此算法中的语句 (7) 的频度不仅与问题规模 n 有关，还与输入实例中 A 的各元素取值及 K 的取值有关:
// ①若 A 中没有与 K 相等的元素，则语句 (3) 的频度 f(n)=n；
// ②若 A 的最后一个元素等于 K, 则语句 (3) 的频度 f(n)是常数 0。
i=n-1;
while (i >= 0 && (A[i] != k)){
  i--;
  return i;
}
```

# 三、总结

* 1、取决于执行次数最多的语句（如当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度 f(n) 决定的）

* 2、如果算法的执行时间不随着问题规模 n 的增加而增长，时间复杂度是 O(1)（即使算法中有上千条语句，其执行时间也不过是一个较大的常数）

* 3、算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。
